07 포인터
===

# 1. 포인터

포인터는 메모리의 주소를 가지고 있는 변수입니다. 

## 메모리

지금까지 사용한 변수들은 메모리에 만들어집니다. 메모리는 각 바이트마다 고유한 주소를 가지고 있습니다. 이들 주소를 이용하여 메모리 각각의 바이트에 접근할 수 있습니다. 

변수가 메모리에 저장될 때 변수의 크기에 따라서 차지하는 공간이 다릅니다. 일반적으로 char형은 1바이트, int형은 4바이트, float형은 4바이트를 차지합니다.

```c++
void main(){
    int i = 10;
    char c = 69;
    float f = 12.3
}
```

다음과 같이 세 변수들을 생성하면 메모리상에는 이렇게 배치가 됩니다. 이는 예시일 뿐 실제로는 그렇게 되지 않습니다.

<img src="img/07%20메모리.png">

## 변수의 주소

C++에서 변수의 주소는 &(주소연산자)를 통해서 알 수 있습니다.

```c++
// 주소 연산자
#include <iostream>
using namespace std;

int main()
{
	int i = 10;
	char c = 69;
	double f = 12.3;

	cout << "i의 주소: " << &i << endl;	// 변수 i의 주소출력
	cout << "c의 주소: " << (void *)&c << endl;	// 변수 c의 주소출력
	cout << "f의 주소: " << &f << endl;	// 변수 f의 주소출력

	return 0;
}
```

실제로 앞서 예시와는 결과가 다를 수 있습니다. 메모리 공간에 변수를 배치하는 것은 컴파일러의 권한이기 때문입니다.

## 포인터 선언

포인터도 변수이기에 선언할 수 있습니다. 포인터의 이름은 일반적인 변수 이름 규칙과 동일하게 적용됩니다. 포인터를 선언하려면 포인터가 가르키게 될 자료형을 쓰고 *를 붙인 다음 포인터의 이름을 적습니다.

```c++
int *pa;    //정수를 가르키는 포인터
```

위에서는 포인터를 선언만하고 아직 초기화하지 않았으므로 포인터가 현재 가지고 있는 값은 아무런 의미도 없는 값이 들어있습니다. 다른 자료형을 가르키는 포인터 또한 아래과 같이 만들 수 있습니다.

```c++
char *pc;
float *pf;
double *pd;
```

## 포인터 초기화

포인터에 변수의 주소를 저장하려면 & 연산자를 이용해야 합니다. & 연산자는 앞서 배웟든 변수의 주소를 나타내는 연산자입니다.

```c++
int i = 10;

int *p1 = &i;

int *p2;
p2 = &i;

int *p3 = NULL; //포인터 p3가 아무것도 가리키지 않음을 의미한다.
```

포인터는 선언시 지정한 자료형의 변수만 가리킬 수 있습니다. int형 포인터는 int형 변수만 가리킬 수 있다는 것 입니다.

## 간접 참조 연산자 *

포인터가 단순히 메모리의 주소만 저장할 수 있는 것이라면 별로 유용하지 않을 것입니다. 포인터가 유용한 이유는 포인터를 통하여 포인터가 가리키는 위치의 값을 읽어오거나 변경할 수 있기 때문입니다. 포인터 p가 가리키는 위치에 저장된 내용을 가져오려면 p 앞에 * 기호를 붙여서 *p라고 하면 됩니다. 이것을 포인터를 통하여 간접 참조 한다고 합니다.

* 연산자는 곱셈 연산자가 아닌 포인터가 가리키는 주소의 값을 가져오는 연산자입니다.

```c++
int i = 10;
int *pi = &i;

*p = 30;     
// p = 30; 이것은 p의 주소를 바꾼다는 의미이므로 유의해야 한다.

cout<<*p<<endl;
```

## 예제

```c++
#include <iostream>
using namespace std;

int main()
{
	int i = 3000;
	int *p = &i;			// 변수와 포인터 연결
	
	cout << &i << endl;	// 변수의 주소 출력
	cout << p << endl;	// 포인터의 값 출력

	cout << i << endl;	// 변수의 값 출력
	cout << *p << endl;	// 포인터를 통한 간접 참조 값 출력

	return 0;
}	
```

## 예제

```c++
#include <iostream>
using namespace std;

int main()
{
	char c = 'A';		// 문자형 변수 정의
	int i = 10000;	// 정수형 변수 정의
	double d = 6.78;	// 실수형 변수 정의

	char *pc = &c;	// 문자형 포인터 정의 및 초기화
	int *pi = &i;         // 정수형 포인터 정의 및 초기화
	double *pd = &d;     // 실수형 포인터 정의 및 초기화

	(*pc)++;		// 간접 참조로 1 증가
	*pi = *pi + 1;	// 간접 참조로 1 증가
	*pd += 1;		// 간접 참조로 1 증가

	cout << c << endl;
	cout << i << endl;
	cout << d << endl;
		
	return 0;
}
```

## 중간정검

1. 포인터도 변수인가?
2. 변수의 주소를 알아내는 데 사용하는 연산자는?

# 2. 포인터 연산

포인터도 변수이고 메모리의 주소를 값으로 가지고 있으므로 값을 더하거나 뺄 수 있습니다. 포인터에 대해서는 사칙연산중 덧셈과 뺄셈만 의미가 있습니다.

## 덧셈과 뺄셈

```c++
// 포인터의 증감 연산
#include <iostream>
using namespace std;

int main()
{
	char *pc; 
	int *pi;
	double *pd;
	
	pc = (char *)10000;			
	pi = (int *)10000;			
	pd = (double *)10000;			
	cout << "증가 전 pc = " << (void *)pc << "pi = " << pi << "pd = " << pd << endl;
	
	pc++;
	pi++;
	pd++;
	cout << "증가 후 pc = " <<  (void *)pc << "pi = " << pi << "pd = " << pd << endl;
	
	return 0;
}
```

## 간접 참조 연산자와 증감연산자

++, --와 같은 증감연산자도 간접 참조 연산자와 같이 사용할 수 있습니다. 하지만 연산자 우선순위를 유의해서 사용해야 합니다. 

|수식|의미|
|:---:|:---|
|v = *p++|p가 가리키는 값을 v에 대입한 후에 p를 증가시킨다.|
|v = (*p)++|p가 가리키는 값을 v에 대입한 후에 p가 가리키는 값을 증가시킨다|
|v = *++p|p를 증가시킨 후에 p가 가리키는 값을 v에 대입한다.|
|v = ++*p|p가 가리크는 값을 가져온 후에 그 값을 증가하여 v에 대입한다.|

## 예제 포인터의 증감 연산

```c++
// 포인터의 증감 연산
#include <iostream>
using namespace std;

int main()
{
	int i = 10;
	int *pi = &i;
	
	cout << "i = " << i << " pi = " << pi << endl;
	(*pi)++;	
	cout << "i = " << i << " pi = " << pi << endl;
	*pi++;	
	cout << "i = " << i << " pi = " << pi << endl;
	
	return 0;
}
```

# 3. 포인터와 배열

포인터와 배열은 아주 밀접한 관계를 가지고 있습니다. 왜냐하면 배열 이름 그 자체가 포인터이기 떄문입니다. 배열 이름은 첫번째 원소의 주소와 같습니다.

```c++
// 포인터의 증감 연산
#include <iostream>
using namespace std;

int main()
{
	int a[] = { 10, 20, 30, 40, 50 };
	
	cout << "&a[0] = " << &a[0] << endl; 
	cout << "&a[1] = " << &a[1] << endl; 
	cout << "&a[2] = " << &a[2] << endl; 
	
	cout << "a = " << a << endl; 
	
	return 0;
}
```

```c++
#include <iostream>
using namespace std;

int main()
{
 
	int a[] = { 10, 20, 30, 40, 50 };

	cout << "a = " << a << endl; 
	cout << "a + 1 = " << a+1 << endl; 
	cout << "*a = " << *a << endl; 
	cout << "*(a+1) " << *(a+1) << endl; 

	return 0;
}
```

## 배열 과 포인터 배열

- 배열 : n개의 값을 저장하는 변수
- 포인터 배열 : n개의 포인터를 저장하는 변수

```c++
int array1[100];	
int *array2[100];
```

# 4. 동적 할당 메모리

## 포인터의 용도

앞서 변수의 주소를 포인터에 저장하고 포인터를 이용하여 변수의 값을 변경할 수 있었습니다. 실제 프로그래밍에서 이런 용도로 포인터를 사용하는 것은 아닙니다. 포인터를 사용하는 경우는 다음과 같습니다.

- 동적으로 할당된 메모리를 사용하는 경우
- 함수의 매개 변수로 변수의 주소를 전달하는 경우
- 클래스의 멤버 변수나 멤버 함수를 호출하는 경우

## 동적 할당 메모리의 개념

보통 프로그램이 메모리를 할당받는 방법에는 **정적(static)**과 **동적(dynamic)** 2가지 방법이 있습니다. 

### 정적 할당

정적 메모리 할당은 **프로그램이 시작되기 전에 미리 정해진 크기의 메모리를 할당 받는 것**을 말합니다. 이 경우, 메모리의 크기는 프로그램이 시작하기 전에 결정되며 프로그램의 수행 도중에 그 크기가 변경될 수는 없습니다.

예를 들어 아래와 같이 변수나 배열을 선언하면 정적으로 메모리를 할당받는 것 입니다.

```c++
int i,j;
int buffer[80];
char name[] = "data structure";
```

정적 메모리 할당은 아주 간단하게 메모리를 할당할 수 있는 방법이지만 경우에 따라 비효율적일 수 있습니다. 프로그램이 처리해야 하는 입력의 크기를 미리 알 수 없는 경우에는 고정된 크기의 메모리를 할당할 수 밖에 없지만, 만약 처음에 결정된 크기보다 더 큰 입력이 들어온다면 이를 처리하지 못하며 더 작은 입력에 대해서는 메모리가 낭비될 수 있습니다.

## 동적 할당

동적 메모리 할당은 프로그램의 실행 도중에 동적으로 메모리를 할당받는 것을 말합니다. 프로그램에서는 필요한 만큼의 메모리를 시스템으로 부터 할당받아서 사용하고 사용이 끝나면 시스템에 메모리를 반납합니다.

필요한 만큼만 할당받고 사용후 반납을 하기 때문에 메모리를 효율적으로 사용할 수 습니다. 동적 메모리는 C++에서 new와 delete 연산자를 이용하여 메모리에 할당 및 반납을 할 수 있습니다.

## 동적 메모리의 위치

컴퓨터에는 메모리가 있습니다. 그리고 C++에서는 그 메모리를 몇가지의 영역으로 나누어서 사용하고 있습니다.

- 코드 공간(code space) : 코드 공간에는 프로그램 코드가 저장된다.
- 전역 공간(global namespace) : 전역 공간에는 전역 변수들이 생성된다.
- 스택(stack) : 스택은 프로그램이 실행하면서 사용하는 공간입니다. 

	주로 함수 호출 시에 매개 변수와 함수 안의 지역 변수를 생성하는 공간입니다. 함수 호출 시에 스택에 할당된 공간은 함수 호출이 끝나면 사라지게 됩니다. 따라서 프로그래머가 별도로 메모리를 반납할 필요가 없습니다.

- 힙(heap) : 힙은 동적 할당을 이용한 것들을 생성하는 공간입니다. 정적 변수도 이곳에 포함됩니다. 

	힙의 장점은 힙에서 할당받으면 함수가 종료되더라도 메모리 공간이 없어지지 않는다는 것이다. 하지만 힙에서 할당받은 공간은 **반드시 반납**하여야 한다. 반납하지 않고 계속 사용할 경우 시스템이 멈출수 있습니다. 이런 것을 메모리 누수라고 합니다.

## 동적 메모리 사용 절차

1. 동적 메모리 할당
2. 동적 메모리 사용
3. 동적 메모리 반납 - 동적 메모리는 자동으로 반납되지 않기 때문에 꼭 직접(명시적) 반납을 해야 합니다.

```c++
#include <iostream>
using namespace std;

void main(){
	int *pi;

	pi = new int;	// 1. 동적 메모리 할당

	*pi = 100;		// 2. 동적 메모리 사용
	delete pi;		// 3. 동적 메모리 반납
}
```

## 메모리 누수

```c++
void example(){
	int *p = new int;
	*p = 60;

	p = new int;
	*p = 30;
}
```

위의 예제는 메모리 누수를 표현한 코드입니다. 먼저 포인터 p를 동적할당 하여 60을 대입하였는데, 반납하지 않고 다시 다른 공간을 할당합니다. 이렇게 되면 기존에 공간은 더이상 사용할 수도 반납할 수 도 없는 상태가 됩니다. 이것을 방지 하기 위해서는 함수 안에서도 지역 변수로 포인터를 사용 한 뒤에 반납을 해야 합니다.

```c++
void example(){
	int *p = new int;
	*p = 60;

	delete p;

	p = new int;
	*p = 30;

	delete p;
}
```

# 5. 참조에 의한 호출(call by reference)

두 변수의 값을 바꾸는 함수 swap()을 통해서 값에 의한 호출과 참조에 의한 호출의 차이점을 알아보겠습니다.

## 값에 의한 호출

```c++
#include <iostream>
using namespace std;

void swap(int x, int y){	//인자를 값으로 받음
	int temp = x;
	x = y;
	y = temp;
}

void main(){
	int a = 100, b = 200;

	cout<<a<<" "<<b<<endl;
	swap(a,b);
	cout<<a<<" "<<b<<endl;
}
```

## 참조에 의한 호출

```c++
#include <iostream>
using namespace std;

void swap(int *x, int *y){	//인자를 포인터로 받음
	int temp = *x;
	*x = *y;
	*y = temp;
}

void main(){
	int a = 100, b = 200;

	cout<<a<<" "<<b<<endl;
	swap(&a,&b);
	cout<<a<<" "<<b<<endl;
}
```